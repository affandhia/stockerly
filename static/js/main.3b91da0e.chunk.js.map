{"version":3,"sources":["recoil/fetch.ts","recoil/idAutocomplete.ts","StickerId.tsx","constants/config.ts","ImageItem.tsx","GridImages.tsx","Detail.tsx","constants/endpoint.ts","constants/data.ts","Recoil.tsx","ReactQuery.tsx","Theme.tsx","App.tsx","index.tsx"],"names":["fetchConfigState","atom","key","default","autocompleteState","filter","createFilterOptions","StickerId","useLocalStorage","isVisible","setVisible","autocomplete","useRecoilValue","useState","idSearch","setIdSearch","useRecoilState","setFetch","updateSearch","useCallback","debounce","isForceIdSearch","headers","url","useEffect","length","packId","FormControlLabel","control","Switch","checked","onChange","event","target","name","label","Collapse","in","AppBar","position","color","sx","top","bottom","Box","p","Autocomplete","id","freeSolo","getOptionLabel","option","_","value","filterOptions","options","params","filtered","inputValue","isExisting","some","push","authorName","thumbnailImageUrl","renderOption","props","display","flexDirection","paddingRight","justifyContent","alignItems","src","width","height","renderInput","TextField","ImageItem","canvasRef","useRef","imgContainerRef","imgRef","current","canvas","getContext","ctx2d","img1","Image","onload","drawImage","crossOrigin","handleCopyImage","a","console","log","axios","get","useCopyImage","Card","CardActionArea","ref","style","CardActions","IconButton","onClick","component","FileCopy","href","PhotoSizeSelectLarge","GridImages","stickers","resourceUrlPrefix","breakpoints","Array","fill","map","index","reduce","obj","cur","columnsCountBreakPoints","gutter","sticker","imgUrl","fileName","Detail","fetchConfig","useQuery","then","response","data","error","Error","JSON","stringify","enabled","isLoading","setAutocomplete","local","setLocal","maxItem","result","item","slice","useAutocomplete","Fade","LinearProgress","Alert","severity","AlertTitle","paddingBottom","Recoil","children","queryClient","QueryClient","ReactQuery","QueryClientProvider","client","Theme","prefersDarkMode","useMediaQuery","theme","useMemo","createTheme","palette","mode","ThemeProvider","CssBaseline","App","rootElement","document","getElementById","render"],"mappings":"4PAQaA,EAAmBC,YAAiC,CAC/DC,IAAK,mBACLC,QAAS,OCCEC,EAAoBH,YAAgC,CAC/DC,IAAK,oBACLC,QAAS,O,OCGLE,EAASC,cAmHAC,EAjHG,WAChB,MAAgCC,YCnBQ,8BDqBtC,GAFF,mBAAOC,EAAP,KAAkBC,EAAlB,KAIMC,EAAeC,YAAeR,GACpC,EAAgCS,qBAAhC,mBAAOC,EAAP,KAAiBC,EAAjB,KACA,EAAqBC,YAAehB,GAA3BiB,EAAT,oBAEMC,EAAeC,sBACnBC,KAAS,SAACN,GACJL,GACFQ,EAAS,CACPI,iBAAiB,EACjBC,QAAS,GACTC,IAAI,2CAAD,OAA6CT,OAGnD,KACH,CAACL,EAAWQ,IAcd,OAXAO,qBAAU,WACRN,EAAaJ,KACZ,CAACA,EAAUI,IAEdM,qBAAU,WACR,UAAIb,QAAJ,IAAIA,KAAcc,OAAQ,CACxB,IAAQC,EAAWf,EAAa,GAAxBe,OACRX,EAAYW,MAEb,IAGD,qCACE,cAACC,EAAA,EAAD,CACEC,QACE,cAACC,EAAA,EAAD,CACEC,QAASrB,EACTsB,SAAU,SAACC,GACTtB,EAAWsB,EAAMC,OAAOH,UAE1BI,KAAK,aAGTC,MAAM,iBAER,cAACC,EAAA,EAAD,CAAUC,GAAI5B,EAAd,SACE,cAAC6B,EAAA,EAAD,CACEC,SAAS,QACTC,MAAM,UACNC,GAAI,CAAEC,IAAK,OAAQC,OAAQ,GAH7B,SAKE,cAACC,EAAA,EAAD,CAAKH,GAAI,CAAEI,EAAG,GAAd,SACE,cAACC,EAAA,EAAD,CACEC,GAAG,iBACHC,UAAQ,EACRC,eAAgB,SAACC,GAAD,OAAYA,EAAOxB,QACnCK,SAAU,SAACoB,EAAGC,GACS,kBAAVA,EACTrC,EAAYqC,GACHA,GAAOrC,EAAYqC,EAAM1B,SAEtC2B,cAAe,SAACC,EAASC,GACvB,IAAMC,EAAWnD,EAAOiD,EAASC,GAEzBE,EAAeF,EAAfE,WAEFC,EAAaJ,EAAQK,MACzB,SAACT,GAAD,OAAYO,IAAeP,EAAOxB,UAWpC,MATmB,KAAf+B,GAAsBC,GACxBF,EAASI,KAAK,CACZlC,OAAQ+B,EACRvB,KAAM,qBACN2B,WAAY,cACZC,kBAAmB,KAIhBN,GAETO,aAAc,SAACC,EAAOd,GAAR,OACZ,eAACN,EAAA,EAAD,yBAAKH,GAAI,CAAEwB,QAAS,OAAQC,cAAe,QAAaF,GAAxD,cACE,cAACpB,EAAA,EAAD,CACEH,GAAI,CACF0B,aAAc,QACdF,QAAS,OACTG,eAAgB,SAChBC,WAAY,UALhB,SAQE,qBACEC,IAAKpB,EAAOY,kBACZS,MAAM,KACNC,OAAO,SAGX,cAAC5B,EAAA,EAAD,sBAAWM,EAAOxB,OAAlB,cAA8BwB,EAAOhB,KAArC,mBAA+CgB,EAAOW,mBAG1DY,YAAa,SAAClB,GAAD,OACX,cAACmB,EAAA,EAAD,2BAAenB,GAAf,IAAuBpB,MAAM,iBAE/BmB,QAAO,OAAE3C,QAAF,IAAEA,IAAgB,e,+LEnBxBgE,EAlCG,SAAC,GAAa,IAAXL,EAAU,EAAVA,IACnB,EAhEmB,SAAC,GAA8B,IAA5BA,EAA2B,EAA3BA,IAChBM,EAAYC,iBAA0B,MACtCC,EAAkBD,iBAAuB,MACzCE,EAASF,iBAAyB,MAyDxC,OAvDArD,qBAAU,WACR,GAAIoD,EAAUI,QAAS,CACrB,IAAMC,EAASL,EAAUI,QACzB,GAAIC,EAAOC,WAAY,CACrB,IAAMC,EAAQF,EAAOC,WAAW,MAE1BE,EAAO,IAAIC,MAEjBD,EAAKE,OAAS,WAEP,OAALH,QAAK,IAALA,KAAOI,UAAUH,EAAM,EAAG,EAAG,IAAK,MAGpCA,EAAKI,YAAc,YACnBJ,EAAKd,IAAMA,MAGd,CAACA,IAsCG,CAAEmB,gBApCetE,sBAAW,sBAAC,sBAAAuE,EAAA,6DAClCC,QAAQC,IAAI,oBAAqBtB,GADC,SAEXuB,IAAMC,IAAIxB,EAAK,CACpChD,QAAS,CACP,8BAA+B,IAC/B,+BAAgC,uCALF,yDAkCjC,CAACgD,IAEsBM,YAAWG,SAAQD,mBAImBiB,CAAa,CAC3EzB,QADMmB,EAAR,EAAQA,gBAAiBb,EAAzB,EAAyBA,UAAWG,EAApC,EAAoCA,OAAQD,EAA5C,EAA4CA,gBAI5C,OACE,mCACE,eAACkB,EAAA,EAAD,WACE,eAACC,EAAA,EAAD,WACE,qBAAKC,IAAKpB,IACV,wBAAQoB,IAAKtB,EAAWuB,MAAO,CAAElC,QAAS,UAC1C,cAAC,IAAD,CAAUO,OAAQ,IAAlB,SACE,qBAAK0B,IAAKnB,EAAQT,IAAKA,EAAKC,MAAM,cAGtC,eAAC6B,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,CACEC,QAASb,EACTjD,MAAM,YACN+D,UAAU,OAHZ,SAKE,cAACC,EAAA,EAAD,MAEF,mBAAGvE,OAAO,SAASwE,KAAI,wCAAmCnC,GAA1D,SACE,cAAC+B,EAAA,EAAD,CAAY7D,MAAM,YAAY+D,UAAU,OAAxC,SACE,cAACG,EAAA,EAAD,iBCrECC,EApBI,SAAC,GAA6C,IAA3CC,EAA0C,EAA1CA,SAAUC,EAAgC,EAAhCA,kBACxBC,EAAcC,MAAM,IACvBC,KAAK,GACLC,KAAI,SAAC9D,EAAG+D,GAAJ,OAAcA,KAClBC,QAAO,SAACC,EAAKC,GAAN,mBAAC,eAAmBD,GAApB,4BAA6BC,EAA7B,MAAuCA,MAAQ,IAEzD,OACE,mCACE,cAAC,oBAAD,CAAmBC,wBAAyBR,EAA5C,SACE,cAAC,IAAD,CAASS,OAAO,KAAhB,SACGX,EAASK,KAAI,SAACO,GACb,IAAMC,EAAM,UAAMZ,GAAN,OAA0BW,EAAQE,UAC9C,OAAO,cAAC,EAAD,CAAwBpD,IAAKmD,GAAbA,aCkHpBE,EAzCA,WAAO,IAAD,EACbC,EA/DahH,YAAeZ,GAiElC,EAAmC6H,YACjC,CC9FkB,+CD8FTD,GADgC,sBAEzC,4BAAAlC,EAAA,sEACyBG,IAAM,CAC3BtE,IAAG,OAAEqG,QAAF,IAAEA,OAAF,EAAEA,EAAarG,IAClBD,QAAO,OAAEsG,QAAF,IAAEA,OAAF,EAAEA,EAAatG,UACrBwG,MAAK,SAACC,GAAD,OAAcA,EAASC,QAJjC,YACQD,EADR,QAMeE,MANf,sBAM4B,IAAIC,MAAMC,KAAKC,UAAUL,EAASE,QAN9D,gCAOSF,GAPT,2CASA,CACEM,UAAWT,IAZPU,EAAR,EAAQA,UAAWL,EAAnB,EAAmBA,MAAOD,EAA1B,EAA0BA,KAkB1B,OA9EsB,SAACM,EAAoBN,GAC3C,MAAwChH,YAAeZ,GAAvD,mBAAOO,EAAP,KAAqB4H,EAArB,KACA,EAA0B/H,YEnCW,6BFqCnC,IAFF,mBAAOgI,EAAP,KAAcC,EAAd,KAIA,EAAkBjI,YHrClB,uCGqCyE,IAAlEkI,EAAP,oBAGAlH,qBAAU,WACY,MAAhBb,GAAwB6H,GAG1BD,EAAgBC,KAEjB,CAAC7H,EAAc6H,EAAOD,IAGzB/G,qBAAU,WACY,MAAhBb,GAEF8H,EAAS9H,KAEV,CAACA,EAAc8H,IAGlBjH,qBAAU,WACR,IAAkB,IAAd8G,GAAA,OAAuBN,QAAvB,IAAuBA,KAAMW,OAAQ,CAEvC,MAMIX,EAAKW,OALP9E,EADF,EACEA,WACAnC,EAFF,EAEEA,OACAQ,EAHF,EAGEA,KACA2E,EAJF,EAIEA,kBACAD,EALF,EAKEA,SAEIgC,EAAO,CACX/E,aACAnC,SACAQ,OACA4B,kBAAkB,GAAD,OAAK+C,GAAL,OACfD,EAASnF,QAAUmF,EAAS,GAAGc,WAGnB,OAAZ/G,QAAY,IAAZA,KAAcc,QAAUd,EAAa,GAAGe,SAAWA,EAErD6G,EACE,CACEK,GADF,mBAEKjI,EAAaN,QAAO,SAACuI,GAAD,OAAUA,EAAKlH,SAAWA,OACjDmH,MAAM,EAAGH,IAEqB,KAAb,OAAZ/H,QAAY,IAAZA,OAAA,EAAAA,EAAcc,SAAc8G,EAAgB,CAACK,OAEzD,CAACjI,EAAc4H,EAAiBD,EAAWN,EAAMU,IAsBpDI,CAAgBR,EAAWN,GAGzB,qCACE,cAACe,EAAA,EAAD,CAAM1G,GAAIiG,EAAV,SACE,cAACU,EAAA,EAAD,MAEF,cAAC5G,EAAA,EAAD,CAAUC,KAAM4F,EAAhB,SACE,eAACgB,EAAA,EAAD,CAAOC,SAAS,QAAhB,UACE,cAACC,EAAA,EAAD,4BACA,mEAGJ,cAAC/G,EAAA,EAAD,CAAUC,KAAM2F,EAAhB,SACE,cAACpF,EAAA,EAAD,CAAKH,GAAI,CAAE2G,cAAe,QAA1B,UACO,OAAJpB,QAAI,IAAJA,GAAA,UAAAA,EAAMW,cAAN,eAAc/B,WAAY,cAAC,EAAD,eAAgBoB,EAAKW,iBG1H3C,SAASU,EAAT,GAA+B,IAAbC,EAAY,EAAZA,SAC/B,OAAO,cAAC,IAAD,UAAaA,I,sBCDhBC,EAAc,IAAIC,IAET,SAASC,EAAT,GAAmC,IAAbH,EAAY,EAAZA,SACnC,OACE,cAACI,EAAA,EAAD,CAAqBC,OAAQJ,EAA7B,SAA2CD,I,4CCFhC,SAASM,GAAT,GAA8B,IAAbN,EAAY,EAAZA,SACxBO,EAAkBC,aAAc,gCAEhCC,EAAQC,mBACZ,kBACEC,aAAY,CACVC,QAAS,CACPC,KAAMN,EAAkB,OAAS,aAGvC,CAACA,IAGH,OACE,eAACO,GAAA,EAAD,CAAeL,MAAOA,EAAtB,UACE,cAACM,GAAA,EAAD,IACCf,KCdQ,SAASgB,KACtB,OACE,mCACE,cAACjB,EAAD,UACE,cAACI,EAAD,UACE,eAACG,GAAD,WACE,cAAC,EAAD,IACA,cAAC,EAAD,aCTZ,IAAMW,GAAcC,SAASC,eAAe,QAC5CC,iBAAO,cAACJ,GAAD,IAASC,M","file":"static/js/main.3b91da0e.chunk.js","sourcesContent":["import { atom } from \"recoil\";\n\ninterface CurlConverterString {\n  url: string;\n  headers: Record<string, string>;\n  isForceIdSearch?: boolean;\n}\n\nexport const fetchConfigState = atom<null | CurlConverterString>({\n  key: \"fetchConfigState\", // unique ID (with respect to other atoms/selectors)\n  default: null // default value (aka initial value)\n});\n","import { atom } from \"recoil\";\nimport { GetStickerResponse } from \"../types\";\n\ninterface MetaData {\n  thumbnailImageUrl: string;\n}\n\nexport interface AutocompleteItem\n  extends Pick<GetStickerResponse[\"result\"], \"authorName\" | \"name\" | \"packId\">,\n    MetaData {}\n\nexport const autocompleteState = atom<null | AutocompleteItem[]>({\n  key: \"autocompleteState\",\n  default: null\n});\n","import { TextField, Collapse, FormControlLabel, Switch } from \"@mui/material\";\nimport { Autocomplete, Box, AppBar, Toolbar } from \"@mui/material\";\nimport debounce from \"lodash/debounce\";\nimport { useRecoilState, useRecoilValue } from \"recoil\";\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useLocalStorage } from \"react-use\";\nimport { createFilterOptions } from \"@mui/material/Autocomplete\";\n\nimport {\n  fetchConfigState,\n  autocompleteState,\n  AutocompleteItem\n} from \"./recoil\";\n\nimport { CONFIG__IS_FORCE_ID_SEARCH } from \"./constants\";\n\nconst filter = createFilterOptions<AutocompleteItem>();\n\nconst StickerId = () => {\n  const [isVisible, setVisible] = useLocalStorage(\n    CONFIG__IS_FORCE_ID_SEARCH,\n    true\n  );\n  const autocomplete = useRecoilValue(autocompleteState);\n  const [idSearch, setIdSearch] = useState<string>();\n  const [, setFetch] = useRecoilState(fetchConfigState);\n\n  const updateSearch = useCallback(\n    debounce((idSearch) => {\n      if (isVisible) {\n        setFetch({\n          isForceIdSearch: true,\n          headers: {},\n          url: `https://api.sticker.ly/v3.1/stickerPack/${idSearch}`\n        });\n      }\n    }, 500),\n    [isVisible, setFetch]\n  );\n\n  useEffect(() => {\n    updateSearch(idSearch);\n  }, [idSearch, updateSearch]);\n\n  useEffect(() => {\n    if (autocomplete?.length) {\n      const { packId } = autocomplete[0];\n      setIdSearch(packId);\n    }\n  }, []);\n\n  return (\n    <>\n      <FormControlLabel\n        control={\n          <Switch\n            checked={isVisible}\n            onChange={(event) => {\n              setVisible(event.target.checked);\n            }}\n            name=\"checkedA\"\n          />\n        }\n        label=\"Search by ID\"\n      />\n      <Collapse in={isVisible}>\n        <AppBar\n          position=\"fixed\"\n          color=\"primary\"\n          sx={{ top: \"auto\", bottom: 0 }}\n        >\n          <Box sx={{ p: 1 }}>\n            <Autocomplete\n              id=\"free-solo-demo\"\n              freeSolo\n              getOptionLabel={(option) => option.packId}\n              onChange={(_, value) => {\n                if (typeof value === \"string\") {\n                  setIdSearch(value);\n                } else if (value) setIdSearch(value.packId);\n              }}\n              filterOptions={(options, params) => {\n                const filtered = filter(options, params);\n\n                const { inputValue } = params;\n                // Suggest the creation of a new value\n                const isExisting = options.some(\n                  (option) => inputValue === option.packId\n                );\n                if (inputValue !== \"\" && !isExisting) {\n                  filtered.push({\n                    packId: inputValue,\n                    name: \"search for this ID\",\n                    authorName: \"press enter\",\n                    thumbnailImageUrl: \"\"\n                  });\n                }\n\n                return filtered;\n              }}\n              renderOption={(props, option) => (\n                <Box sx={{ display: \"flex\", flexDirection: \"row\" }} {...props}>\n                  <Box\n                    sx={{\n                      paddingRight: \"0.5em\",\n                      display: \"flex\",\n                      justifyContent: \"center\",\n                      alignItems: \"center\"\n                    }}\n                  >\n                    <img\n                      src={option.thumbnailImageUrl}\n                      width=\"16\"\n                      height=\"16\"\n                    />\n                  </Box>\n                  <Box>{`[ ${option.packId} ] ${option.name} – ${option.authorName}`}</Box>\n                </Box>\n              )}\n              renderInput={(params) => (\n                <TextField {...params} label=\"Sticker ID\" />\n              )}\n              options={autocomplete ?? []}\n            />\n          </Box>\n        </AppBar>\n      </Collapse>\n    </>\n  );\n};\n\nexport default StickerId;\n","export const CONFIG__IS_FORCE_ID_SEARCH = \"stockerly:config:isForceId\";\nexport const CONFIG__MAX_AUTOCOMPLETE_ITEM =\n  \"stockerly:config:maxAutocompleteItem\";\n","import LazyLoad from \"react-lazyload\";\nimport { Card, CardActionArea, CardActions, IconButton } from \"@mui/material\";\nimport { FileCopy, PhotoSizeSelectLarge } from \"@mui/icons-material\";\nimport { useCallback, useRef, useEffect } from \"react\";\nimport axios from \"axios\";\n\nconst useCopyImage = ({ src }: { src: string }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const imgContainerRef = useRef<HTMLDivElement>(null);\n  const imgRef = useRef<HTMLImageElement>(null);\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      const canvas = canvasRef.current;\n      if (canvas.getContext) {\n        const ctx2d = canvas.getContext(\"2d\");\n\n        const img1 = new Image();\n\n        img1.onload = function () {\n          //draw background image\n          ctx2d?.drawImage(img1, 0, 0, 100, 100);\n        };\n\n        img1.crossOrigin = \"anonymous\";\n        img1.src = src;\n      }\n    }\n  }, [src]);\n\n  const handleCopyImage = useCallback(async () => {\n    console.log(\"downloading image\", src);\n    const response = await axios.get(src, {\n      headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,PUT,POST,DELETE,PATCH,OPTIONS\"\n      }\n    });\n    // if (canvasRef.current) {\n    //   const canvas = canvasRef.current;\n    //   canvas.toBlob(\n    //     async (blob) => {\n    //       try {\n    //         console.log({ blob });\n    //         const image = new window.ClipboardItem({\n    //           [blob.type]: blob\n    //         });\n    //         const result = await navigator.permissions.query({\n    //           name: \"clipboard-write\"\n    //         });\n    //         if (result.state === \"granted\") {\n    //           await navigator.clipboard.write([image]);\n    //           console.log(\"Image copied\");\n    //         } else {\n    //           console.log(\"clipboard-permissoin not granted: \", { result });\n    //         }\n    //       } catch (error) {\n    //         console.error(error);\n    //       }\n    //     },\n    //     \"image/png\",\n    //     0.75\n    //   );\n    // }\n  }, [src]);\n\n  return { handleCopyImage, canvasRef, imgRef, imgContainerRef };\n};\n\nconst ImageItem = ({ src }) => {\n  const { handleCopyImage, canvasRef, imgRef, imgContainerRef } = useCopyImage({\n    src\n  });\n\n  return (\n    <>\n      <Card>\n        <CardActionArea>\n          <div ref={imgContainerRef} />\n          <canvas ref={canvasRef} style={{ display: \"none\" }} />\n          <LazyLoad height={200}>\n            <img ref={imgRef} src={src} width=\"100%\" />\n          </LazyLoad>\n        </CardActionArea>\n        <CardActions>\n          <IconButton\n            onClick={handleCopyImage}\n            color=\"secondary\"\n            component=\"span\"\n          >\n            <FileCopy />\n          </IconButton>\n          <a target=\"_blank\" href={` https://ezgif.com/resize?url=${src}`}>\n            <IconButton color=\"secondary\" component=\"span\">\n              <PhotoSizeSelectLarge />\n            </IconButton>\n          </a>\n        </CardActions>\n      </Card>\n    </>\n  );\n};\n\nexport default ImageItem;\n","import Masonry, { ResponsiveMasonry } from \"react-responsive-masonry\";\n\nimport { Result } from \"./types\";\nimport ImageItem from \"./ImageItem\";\n\nconst GridImages = ({ stickers, resourceUrlPrefix }: Result) => {\n  const breakpoints = Array(10)\n    .fill(1)\n    .map((_, index) => index)\n    .reduce((obj, cur) => ({ ...obj, [`${cur}00`]: cur }), {});\n\n  return (\n    <>\n      <ResponsiveMasonry columnsCountBreakPoints={breakpoints}>\n        <Masonry gutter=\"10\">\n          {stickers.map((sticker) => {\n            const imgUrl = `${resourceUrlPrefix}${sticker.fileName}`;\n            return <ImageItem key={imgUrl} src={imgUrl} />;\n          })}\n        </Masonry>\n      </ResponsiveMasonry>\n    </>\n  );\n};\n\nexport default GridImages;\n","import { useRecoilValue, useRecoilState } from \"recoil\";\nimport { useQuery } from \"react-query\";\nimport {\n  LinearProgress,\n  Fade,\n  Collapse,\n  Box,\n  Alert,\n  AlertTitle\n} from \"@mui/material\";\nimport axios from \"axios\";\nimport { useLocalStorage } from \"react-use\";\n\nimport {\n  fetchConfigState,\n  autocompleteState,\n  AutocompleteItem\n} from \"./recoil\";\nimport { GetStickerResponse } from \"./types\";\nimport {\n  DETAIL,\n  CONFIG__MAX_AUTOCOMPLETE_ITEM,\n  DATA__AUTOCOMPLETE_ITEM\n} from \"./constants\";\nimport GridImages from \"./GridImages\";\nimport { useEffect } from \"react\";\n\nconst useConfig = () => {\n  const curlConfig = useRecoilValue(fetchConfigState);\n\n  return curlConfig;\n};\n\nconst useAutocomplete = (isLoading: boolean, data?: GetStickerResponse) => {\n  const [autocomplete, setAutocomplete] = useRecoilState(autocompleteState);\n  const [local, setLocal] = useLocalStorage<AutocompleteItem[]>(\n    DATA__AUTOCOMPLETE_ITEM,\n    []\n  );\n  const [maxItem] = useLocalStorage<number>(CONFIG__MAX_AUTOCOMPLETE_ITEM, 10);\n\n  /** INIT AUTOCOMPLETE */\n  useEffect(() => {\n    if (autocomplete == null && local) {\n      // if the list is null because it has not been initialized\n      // init list here\n      setAutocomplete(local);\n    }\n  }, [autocomplete, local, setAutocomplete]);\n\n  /** SYNC TO LOCAL STORAGE */\n  useEffect(() => {\n    if (autocomplete != null) {\n      // if there is a changes in autocomplete\n      setLocal(autocomplete);\n    }\n  }, [autocomplete, setLocal]);\n\n  /** SYNC TO RECOIL */\n  useEffect(() => {\n    if (isLoading === false && data?.result) {\n      // if the fetch is success\n      const {\n        authorName,\n        packId,\n        name,\n        resourceUrlPrefix,\n        stickers\n      } = data.result;\n      const item = {\n        authorName,\n        packId,\n        name,\n        thumbnailImageUrl: `${resourceUrlPrefix}${\n          stickers.length && stickers[0].fileName\n        }`\n      };\n      if (autocomplete?.length && autocomplete[0].packId !== packId) {\n        // if the list is different from before\n        setAutocomplete(\n          [\n            item,\n            ...autocomplete.filter((item) => item.packId !== packId)\n          ].slice(0, maxItem)\n        );\n      } else if (autocomplete?.length === 0) setAutocomplete([item]); // if the list from local is empty\n    }\n  }, [autocomplete, setAutocomplete, isLoading, data, maxItem]);\n};\n\nconst Detail = () => {\n  const fetchConfig = useConfig();\n\n  const { isLoading, error, data } = useQuery<GetStickerResponse>(\n    [DETAIL, fetchConfig],\n    async () => {\n      const response = await axios({\n        url: fetchConfig?.url,\n        headers: fetchConfig?.headers\n      }).then((response) => response.data);\n\n      if (response.error) throw new Error(JSON.stringify(response.error));\n      return response;\n    },\n    {\n      enabled: !!fetchConfig\n    }\n  );\n\n  useAutocomplete(isLoading, data);\n\n  return (\n    <>\n      <Fade in={isLoading}>\n        <LinearProgress />\n      </Fade>\n      <Collapse in={!!error}>\n        <Alert severity=\"error\">\n          <AlertTitle>Network Error</AlertTitle>\n          <strong>Unable to get the images</strong>\n        </Alert>\n      </Collapse>\n      <Collapse in={!!data}>\n        <Box sx={{ paddingBottom: \"10em\" }}>\n          {data?.result?.stickers && <GridImages {...data.result} />}\n        </Box>\n      </Collapse>\n    </>\n  );\n};\n\nexport default Detail;\n","export const DETAIL = \"https://api.sticker.ly/v3.1/stickerPack/<id>\";\n","export const DATA__AUTOCOMPLETE_ITEM = \"stockerly:autocompleteItem\";\n","import { RecoilRoot } from \"recoil\";\n\nexport default function Recoil({ children }) {\n  return <RecoilRoot>{children}</RecoilRoot>;\n}\n","import { QueryClient, QueryClientProvider } from \"react-query\";\n\nconst queryClient = new QueryClient();\n\nexport default function ReactQuery({ children }) {\n  return (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n}\n","import { useMemo } from \"react\";\nimport { useMediaQuery, CssBaseline } from \"@mui/material\";\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\";\n\nexport default function Theme({ children }) {\n  const prefersDarkMode = useMediaQuery(\"(prefers-color-scheme: dark)\");\n\n  const theme = useMemo(\n    () =>\n      createTheme({\n        palette: {\n          mode: prefersDarkMode ? \"dark\" : \"light\"\n        }\n      }),\n    [prefersDarkMode]\n  );\n\n  return (\n    <ThemeProvider theme={theme}>\n      <CssBaseline />\n      {children}\n    </ThemeProvider>\n  );\n}\n","import StickerId from \"./StickerId\";\nimport Detail from \"./Detail\";\nimport Recoil from \"./Recoil\";\nimport ReactQuery from \"./ReactQuery\";\nimport Theme from \"./Theme\";\n\nexport default function App() {\n  return (\n    <>\n      <Recoil>\n        <ReactQuery>\n          <Theme>\n            <StickerId />\n            <Detail />\n          </Theme>\n        </ReactQuery>\n      </Recoil>\n    </>\n  );\n}\n","import { render } from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nrender(<App />, rootElement);\n"],"sourceRoot":""}